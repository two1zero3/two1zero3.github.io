/* autogenerated by Processing revision 1289 on 2022-12-13 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import themidibus.*;
import java.util.*;
import processing.sound.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class sketch_221114a extends PApplet {

//Authored by Andreas Abbaszadeh, 2022
//Find creative ways to display notes --> maybe make the squares bounce around / use a grid?
// Rewrite parts of the code that are unclear --> add comments aswell
//Add note sound of note played --> make something more even ?
// WHEN 2 NOTES COLIDE PLAY THE TWO NOTES --> MAKES COLORS ASWELL


 //Import the library



//SETTINGS
PApplet sketch;
int noteLifespan = 500;
float[] randomColors = new float[100];
String MidiName = "MIDI1";
float attackTime = 0.001f;
float sustainTime = 0.004f;
float sustainLevel = 0.3f;
float releaseTime = 0.4f;

MidiBus myBus; // The MidiBus
NoteManager nm;

public void setup() {
  /* size commented out by preprocessor */;
  background(0);

  sketch = this;

  rectMode(CENTER);
  /* pixelDensity commented out by preprocessor */;

  println(this);

  MidiBus.list();
  myBus = new MidiBus(this, MidiName, 1);
  nm = new NoteManager();

  for (int i = 0; i < randomColors.length; i++) {
    randomColors[i] = PApplet.parseInt(random(0, 360));
  }

}

public void draw() {

  background(0);
  nm.track();

}

public void controllerChange(int channel, int number, int value) {

  println("Controller Change: " + channel + ", " + number + ", " + value);

}

public void noteOn(int channel, int pitch, int velocity) {
  nm.addNote(new Note(channel, pitch, velocity, noteLifespan));
  println ("Note on: " + channel + ", " + pitch + ", " + velocity);
}

public void noteOff(int channel, int pitch, int velocity) {
  nm.releaseNote(new Note(channel, pitch, velocity, noteLifespan));
  println("Note off: " + channel + ", " + pitch + ", " + velocity);
}

public static int randomDirection() {

  float rand = new Random().nextFloat();

  if (rand > 0.5f) {
    return 1;
  } else {
    return -1;
  }

}
/*
    Authored by Thomas Castleman, 2018
*/

// Note class handles attributes that all played notes share
class Note {
  
  int channel, velocity, pitch;   // store the channel, velocity and pitch + modulation
  int lifespan;                   // lifespan of note, in frames
  boolean isReleased;             // whether or not the note has been released yet
  float x, y;                     // Position of the note
  float directionX, directionY;    //left to right or right to left / top to down or down to top
  float size;                     // Size of Square when created
  int col;                      // Color of square
  float scale;                      //scale in relation to this.size
  float distToCenter;
  SinOsc sin;

  // constructor for new Note object
  Note(int channel_, int pitch_, int velocity_, int lifespan_) {
    this.channel = channel_;
    this.pitch = pitch_;
    this.velocity = velocity_;
    this.lifespan = lifespan_;

    this.scale = 1;
    this.isReleased = false;
    this.x = width/2;
    //this.x = map(pitch, 48, 84, 0, width); //map notes from note 48 to 84 to be closer to x = 0 or x = width
    this.y = height/2;
    this.directionX = randomDirection();
    this.directionY = randomDirection();
    this.size = map(velocity, 0, 127, 10, 500); //map size of squares to velocity of the note played
    
    this.sin = new SinOsc(sketch);

    pushStyle();
    colorMode(HSB, 360, 100, 100); //make notes span the entire color hue range
    this.col = color(randomColors[pitch], map(velocity, 0, 127, 25, 100), 100); //assign colors in randomColors array to pitch
    popStyle(); // change back to normal
  }
  
  // update note properties
  public void update() {

    //set x and y
    this.x = this.x + 0.0509f*this.velocity*this.directionX;
    this.y = this.y + 0.0619f*this.velocity*this.directionY; // make it go down in Y axis slowly
    this.scale = lerp(this.lifespan, 0, 0.1f) / noteLifespan; //maybe find method to make division by initial lifespan better coded --> set lifespan as passed on variable or for the whole sketch as global variable

    this.distToCenter = this.scale * (this.size/2); //distance from center of square to any side
    //println(distToCenter);

    //bounce mechanics 
    if (this.x > width - this.distToCenter || this.x < this.distToCenter) {
      this.directionX = -this.directionX;
    }
    if (this.y > height - this.distToCenter || this.y < this.distToCenter ) {
      this.directionY = -this.directionY;
    }



    //note collision detection
    Iterator<Note> iter = nm.notes.iterator();

    while(iter.hasNext()) {

      Note n = iter.next();

      if (dist(n.x, n.y, this.x, this.y) < this.distToCenter && this.x != n.x) { //if note x and y is inside this.x this.y and the note is not ourselves

        line(n.x, n.y, this.x, this.y);
        //play note if this is the frame of collision
        this.playNote();
          //println(dist(n.x, n.y, this.x, this.y))
        
      }

    }

  }
  
  // display note on canvas
  public void display() {

    pushMatrix();
    translate(this.x, this.y); //figure out why it is changing x when it shouldn't
    scale(this.scale);  //lerp scale to make transitions smoother

    stroke(255);
    fill(this.col, 127); // 50% transparency
    square(0, 0, this.size); //size square acording to velocity
    
    popMatrix();

  }

  public void playNote() {

        //println(n.pitch + ", " + this.pitch);

        //calc midi pitch to frequency in hz
        float f = (float)Math.pow(2, (this.pitch-69.0f)/12.0f);

        //play note with envelope
        this.sin.freq(f*440);
        this.sin.play();

  }

}
// NoteManager class manages the tracking of MIDI notes, as played live
class NoteManager {
  
  public HashSet<Note> notes = new HashSet<Note>();            // all note objects currently being tracked
  private HashSet<Note> notesToAdd = new HashSet<Note>();      // notes to add to the list of tracked notes
  private HashSet<Note> release = new HashSet<Note>();         // notes that will be released on this iteration of the draw() loop
  private HashSet<Note> notesToRelease = new HashSet<Note>();  // notes waiting for the next iteration of draw() to be released
  
  // construct a new NoteManager object
  public NoteManager() {
     
  }
  
  // add a new note to tracked notes
  public void addNote(Note n) {
    // add note to list of notes that will be tracked in the next iteration of draw()
    notesToAdd.add(n);
  }
  
  // remove a note from tracked notes
  public void releaseNote(Note n) {
    // add note to list of notes that will be released in the next iteration of draw()
    notesToRelease.add(n);
  }
  
  // add new notes to tracked notens, remove old notes from tracked notes
  public void track() {
    this.release.addAll(this.notesToRelease);  // add every note waiting to be released to list of notes about to be released
    this.notesToRelease.clear();  // remove everything from list of notes waiting to be released
    
    // for each note that needs to be released
    for (Note n : this.release) {
      // find its counterpart in the tracked notes array
      for (Note m : this.notes) {
        if (n.channel == m.channel && n.pitch == m.pitch) {
          m.isReleased = true;  // record that this note is now released
        }
      }
    }
    
    this.release.clear();  // remove everything from the list of notes to remove
    
    this.notes.addAll(this.notesToAdd);  // add every note waiting to be kept track of
    this.notesToAdd.clear();  // remove everything from list of notes waiting to be tracked
    
    // iterate through all notes currently being tracked
    Iterator<Note> iter = this.notes.iterator();
    while (iter.hasNext()) {
      Note n = iter.next();
      
      // if note has been released, decrement lifespan
      if (n.isReleased) {
        n.lifespan--;
      }
      
      // update and display each note
      n.update();
      n.display();

      
      
      // if a note is finished, remove from tracked notes
      if (n.lifespan <= 0) {
        iter.remove();
      }
    }
  }
  
}


  public void settings() { size(960, 960);
pixelDensity(displayDensity()); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "sketch_221114a" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
